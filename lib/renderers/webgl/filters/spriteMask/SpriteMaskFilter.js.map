{"version":3,"sources":["../../../../../src/renderers/webgl/filters/spriteMask/SpriteMaskFilter.js"],"names":["SpriteMaskFilter","Filter","constructor","sprite","maskMatrix","Matrix","renderable","maskSprite","apply","filterManager","input","output","clear","tex","texture","valid","transform","TextureMatrix","update","uniforms","mask","otherMatrix","calculateSpriteMatrix","prepend","mapCoord","alpha","worldAlpha","maskClamp","uClampFrame","applyFilter"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AACA;;;;AAGe,MAAMA,gBAAN,SAA+BC,eAA/B,CAAsC;AACnD;AACF;AACA;AACEC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,QAAMC,UAAU,GAAG,IAAIC,YAAJ,EAAnB;AAEA;AAKAF,IAAAA,MAAM,CAACG,UAAP,GAAoB,KAApB;AAEA,SAAKC,UAAL,GAAkBJ,MAAlB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEI,EAAAA,KAAK,CAACC,aAAD,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+BC,KAA/B,EAAsC;AACzC,QAAML,UAAU,GAAG,KAAKA,UAAxB;AACA,QAAMM,GAAG,GAAG,KAAKN,UAAL,CAAgBO,OAA5B;;AAEA,QAAI,CAACD,GAAG,CAACE,KAAT,EAAgB;AACd;AACD;;AACD,QAAI,CAACF,GAAG,CAACG,SAAT,EAAoB;AAClB;AACA;AACAH,MAAAA,GAAG,CAACG,SAAJ,GAAgB,IAAIC,sBAAJ,CAAkBJ,GAAlB,EAAuB,GAAvB,CAAhB;AACD;;AACDA,IAAAA,GAAG,CAACG,SAAJ,CAAcE,MAAd;AAEA,SAAKC,QAAL,CAAcC,IAAd,GAAqBP,GAArB;AACA,SAAKM,QAAL,CAAcE,WAAd,GAA4BZ,aAAa,CACtCa,qBADyB,CACH,KAAKlB,UADF,EACcG,UADd,EAEzBgB,OAFyB,CAEjBV,GAAG,CAACG,SAAJ,CAAcQ,QAFG,CAA5B;AAGA,SAAKL,QAAL,CAAcM,KAAd,GAAsBlB,UAAU,CAACmB,UAAjC;AACA,SAAKP,QAAL,CAAcQ,SAAd,GAA0Bd,GAAG,CAACG,SAAJ,CAAcY,WAAxC;AAEAnB,IAAAA,aAAa,CAACoB,WAAd,CAA0B,IAA1B,EAAgCnB,KAAhC,EAAuCC,MAAvC,EAA+CC,KAA/C;AACD;;AAhDkD","sourcesContent":["import Filter from \"../Filter\";\nimport { Matrix } from \"../../../../math\";\nimport { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { default as TextureMatrix } from \"../../../../textures/TextureMatrix\";\n\n\nexport default class SpriteMaskFilter extends Filter {\n  /**\n   * @param {InkPaint.Sprite} sprite - the target sprite\n   */\n  constructor(sprite) {\n    const maskMatrix = new Matrix();\n\n    super(\n      readFileSync(join(__dirname, \"./spriteMaskFilter.vert\"), \"utf8\"),\n      readFileSync(join(__dirname, \"./spriteMaskFilter.frag\"), \"utf8\")\n    );\n\n    sprite.renderable = false;\n\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n  }\n\n  /**\n   * Applies the filter\n   *\n   * @param {InkPaint.FilterManager} filterManager - The renderer to retrieve the filter from\n   * @param {InkPaint.RenderTarget} input - The input render target.\n   * @param {InkPaint.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clear) {\n    const maskSprite = this.maskSprite;\n    const tex = this.maskSprite.texture;\n\n    if (!tex.valid) {\n      return;\n    }\n    if (!tex.transform) {\n      // margin = 0.0, let it bleed a bit, shader code becomes easier\n      // assuming that atlas textures were made with 1-pixel padding\n      tex.transform = new TextureMatrix(tex, 0.0);\n    }\n    tex.transform.update();\n\n    this.uniforms.mask = tex;\n    this.uniforms.otherMatrix = filterManager\n      .calculateSpriteMatrix(this.maskMatrix, maskSprite)\n      .prepend(tex.transform.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.transform.uClampFrame;\n\n    filterManager.applyFilter(this, input, output, clear);\n  }\n}\n"],"file":"SpriteMaskFilter.js"}