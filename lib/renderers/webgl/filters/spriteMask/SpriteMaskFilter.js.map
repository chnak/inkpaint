{"version":3,"sources":["../../../../../src/renderers/webgl/filters/spriteMask/SpriteMaskFilter.js"],"names":["SpriteMaskFilter","Filter","constructor","sprite","maskMatrix","Matrix","renderable","maskSprite","apply","filterManager","input","output","clear","tex","texture","valid","transform","TextureMatrix","update","uniforms","mask","useBinaryMask","binaryMask","useReverseMask","reverseMask","otherMatrix","calculateSpriteMatrix","prepend","mapCoord","alpha","worldAlpha","maskClamp","uClampFrame","applyFilter"],"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AACA;;;;AAEe,MAAMA,gBAAN,SAA+BC,eAA/B,CAAsC;AACnD;AACF;AACA;AACEC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,QAAMC,UAAU,GAAG,IAAIC,YAAJ,EAAnB;AAEA;AAKAF,IAAAA,MAAM,CAACG,UAAP,GAAoB,KAApB;AAEA,SAAKC,UAAL,GAAkBJ,MAAlB;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEI,EAAAA,KAAK,CAACC,aAAD,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+BC,KAA/B,EAAsC;AACzC,QAAML,UAAU,GAAG,KAAKA,UAAxB;AACA,QAAMM,GAAG,GAAG,KAAKN,UAAL,CAAgBO,OAA5B;AAEA,QAAI,CAACD,GAAG,CAACE,KAAT,EAAgB;;AAChB,QAAI,CAACF,GAAG,CAACG,SAAT,EAAoB;AAClB;AACA;AACAH,MAAAA,GAAG,CAACG,SAAJ,GAAgB,IAAIC,sBAAJ,CAAkBJ,GAAlB,EAAuB,GAAvB,CAAhB;AACD;;AACDA,IAAAA,GAAG,CAACG,SAAJ,CAAcE,MAAd;AAEA,SAAKC,QAAL,CAAcC,IAAd,GAAqBP,GAArB;AACA,SAAKM,QAAL,CAAcE,aAAd,GAA8B,CAAC,CAACd,UAAU,CAACe,UAA3C;AACA,SAAKH,QAAL,CAAcI,cAAd,GAA+B,CAAC,CAAChB,UAAU,CAACiB,WAA5C;AACA,SAAKL,QAAL,CAAcM,WAAd,GAA4BhB,aAAa,CACtCiB,qBADyB,CACH,KAAKtB,UADF,EACcG,UADd,EAEzBoB,OAFyB,CAEjBd,GAAG,CAACG,SAAJ,CAAcY,QAFG,CAA5B;AAGA,SAAKT,QAAL,CAAcU,KAAd,GAAsBtB,UAAU,CAACuB,UAAjC;AACA,SAAKX,QAAL,CAAcY,SAAd,GAA0BlB,GAAG,CAACG,SAAJ,CAAcgB,WAAxC;AACAvB,IAAAA,aAAa,CAACwB,WAAd,CAA0B,IAA1B,EAAgCvB,KAAhC,EAAuCC,MAAvC,EAA+CC,KAA/C;AACD;;AA/CkD","sourcesContent":["import Filter from \"../Filter\";\nimport { Matrix } from \"../../../../math\";\nimport { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { default as TextureMatrix } from \"../../../../textures/TextureMatrix\";\n\nexport default class SpriteMaskFilter extends Filter {\n  /**\n   * @param {InkPaint.Sprite} sprite - the target sprite\n   */\n  constructor(sprite) {\n    const maskMatrix = new Matrix();\n\n    super(\n      readFileSync(join(__dirname, \"./spriteMaskFilter.vert\"), \"utf8\"),\n      readFileSync(join(__dirname, \"./spriteMaskFilter.frag\"), \"utf8\")\n    );\n\n    sprite.renderable = false;\n\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n  }\n\n  /**\n   * Applies the filter\n   *\n   * @param {InkPaint.FilterManager} filterManager - The renderer to retrieve the filter from\n   * @param {InkPaint.RenderTarget} input - The input render target.\n   * @param {InkPaint.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clear) {\n    const maskSprite = this.maskSprite;\n    const tex = this.maskSprite.texture;\n\n    if (!tex.valid) return;\n    if (!tex.transform) {\n      // margin = 0.0, let it bleed a bit, shader code becomes easier\n      // assuming that atlas textures were made with 1-pixel padding\n      tex.transform = new TextureMatrix(tex, 0.0);\n    }\n    tex.transform.update();\n\n    this.uniforms.mask = tex;\n    this.uniforms.useBinaryMask = !!maskSprite.binaryMask;\n    this.uniforms.useReverseMask = !!maskSprite.reverseMask;\n    this.uniforms.otherMatrix = filterManager\n      .calculateSpriteMatrix(this.maskMatrix, maskSprite)\n      .prepend(tex.transform.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.transform.uClampFrame;\n    filterManager.applyFilter(this, input, output, clear);\n  }\n}\n"],"file":"SpriteMaskFilter.js"}