{"version":3,"sources":["../../../src/filters/transition/TransitionFilter.js"],"names":["TransitionFilter","Filter","constructor","transition","vert","frag","replace","glsl","fromMatrix","Matrix","toMatrix","apply","filterManager","input","output","key","k","uniforms","calculateSpriteMatrix","prev","fromSprite","next","toSprite","sprite","setSprite","ratio","params","unit","paramsTypes","value","defaultParams","console","warn","bind","Error","renderable","tex","texture","transform","TextureMatrix","update","uClampFrame","updateProgress","progress"],"mappings":"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","sourcesContent":["import Filter from \"../../renderers/webgl/filters/Filter\";\nimport Matrix from \"../../math/Matrix\";\nimport Point from \"../../math/Point\";\nimport { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { default as TextureMatrix } from \"../../textures/TextureMatrix\";\n\nexport default class TransitionFilter extends Filter {\n  constructor(transition) {\n    let vert = readFileSync(join(__dirname, \"./trans.vert\"), \"utf8\");\n    let frag = readFileSync(join(__dirname, \"./trans.frag\"), \"utf8\");\n    frag = frag.replace('${transitionGlsl}', transition.glsl);\n    super(vert, frag);\n\n    this.fromMatrix = new Matrix();\n    this.toMatrix = new Matrix();\n    this.transition = transition;\n  }\n\n  apply(filterManager, input, output) {\n    for (const key of ['from', 'to']) {\n      const k = `${key}Matrix`;\n      this.uniforms[k] = filterManager.calculateSpriteMatrix(this[k], this[`${key}Sprite`]);\n    }\n    super.apply(filterManager, input, output);\n  }\n\n  get prev() {\n    return this.fromSprite;\n  }\n\n  get next() {\n    return this.toSprite;\n  }\n\n  set prev(sprite) {\n    this.setSprite('from', sprite);\n  }\n\n  set next(sprite) {\n    this.setSprite('to', sprite);\n  }\n\n  get ratio() {\n    return this.uniforms.ratio;\n  }\n\n  set ratio(ratio) {\n    this.uniforms.ratio = ratio;\n  }\n\n  set params(params) {\n    let unit = 2;\n    const { transition, uniforms } = this;\n    for (let key in transition.paramsTypes) {\n      const value = key in params\n        ? params[key]\n        : transition.defaultParams[key];\n      if (transition.paramsTypes[key] === \"sampler2D\") {\n        if (!value) {\n          console.warn(\n            \"uniform[\" +\n              key +\n              \"]: A texture MUST be defined for uniform sampler2D of a texture\"\n          );\n        } else if (typeof value.bind !== \"function\") {\n          throw new Error(\n            \"uniform[\" +\n              key +\n              \"]: A gl-texture2d API-like object was expected\"\n          );\n        } else {\n          uniforms[key] = value.bind(unit++);\n        }\n      } else {\n        uniforms[key] = value;\n      }\n    }\n  }\n\n  setSprite(key, sprite) {\n    this[`${key}Sprite`] = sprite;\n    sprite.renderable = false;\n    let tex = sprite.texture;\n    if (!tex.transform) {\n      // margin = 0.0, let it bleed a bit, shader code becomes easier\n      // assuming that atlas textures were made with 1-pixel padding\n      tex.transform = new TextureMatrix(tex, 0.0);\n    }\n    tex.transform.update();\n    this.uniforms[`${key}Sampler`] = tex;\n    this.uniforms[`${key}ClampFrame`] = tex.transform.uClampFrame;\n  }\n\n  updateProgress(progress) {\n    this.uniforms.progress = progress;\n  }\n}\n"],"file":"TransitionFilter.js"}