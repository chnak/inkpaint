{"version":3,"sources":["../../../src/sprites/canvas/CanvasSpriteRenderer.js"],"names":["canvasRenderWorldTransform","Matrix","CanvasSpriteRenderer","constructor","renderer","render","sprite","texture","_texture","width","_frame","height","wt","transform","worldTransform","dx","dy","orig","baseTexture","source","setBlendMode","blendMode","valid","context","globalAlpha","worldAlpha","smoothingEnabled","scaleMode","SCALE_MODES","LINEAR","smoothProperty","anchor","x","y","rotate","copy","GroupD8","matrixAppendRotationInv","roundPixels","setTransform","a","b","c","d","tx","resolution","ty","adaptedNodeCanvas","sx","sy","dw","dh","trim","drawImage","isPSCanvas","isImageData","PsImage","convertToCanvas","data","length","destroy","CanvasRenderer","registerPlugin"],"mappings":"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","sourcesContent":["import CanvasRenderer from \"../../renderers/canvas/CanvasRenderer\";\nimport { SCALE_MODES } from \"../../const\";\nimport { Matrix, GroupD8 } from \"../../math\";\nimport PsImage from \"../../polyfill/Image\";\nimport CanvasTinter from \"./CanvasTinter\";\n\nconst canvasRenderWorldTransform = new Matrix();\n\nexport default class CanvasSpriteRenderer {\n  constructor(renderer) {\n    this.renderer = renderer;\n  }\n\n  render(sprite) {\n    const texture = sprite._texture;\n    const renderer = this.renderer;\n\n    const width = texture._frame.width;\n    const height = texture._frame.height;\n\n    let wt = sprite.transform.worldTransform;\n    let dx = 0;\n    let dy = 0;\n\n    if (\n      texture.orig.width <= 0 ||\n      texture.orig.height <= 0 ||\n      !texture.baseTexture.source\n    ) {\n      return;\n    }\n\n    renderer.setBlendMode(sprite.blendMode);\n\n    //  Ignore null sources\n    if (texture.valid) {\n      renderer.context.globalAlpha = sprite.worldAlpha;\n\n      const smoothingEnabled =\n        texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n      if (\n        renderer.smoothProperty &&\n        renderer.context[renderer.smoothProperty] !== smoothingEnabled\n      ) {\n        renderer.context[renderer.smoothProperty] = smoothingEnabled;\n      }\n\n      // if (texture.trim) {\n      //   dx =\n      //     texture.trim.width / 2 +\n      //     texture.trim.x -\n      //     sprite.anchor.x * texture.orig.width;\n      //   dy =\n      //     texture.trim.height / 2 +\n      //     texture.trim.y -\n      //     sprite.anchor.y * texture.orig.height;\n      // } else {\n      //   dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n      //   dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n      // }\n\n      dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n      dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n\n      if (texture.rotate) {\n        wt.copy(canvasRenderWorldTransform);\n        wt = canvasRenderWorldTransform;\n        GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n        // the anchor has already been applied above, so lets set it to zero\n        dx = 0;\n        dy = 0;\n      }\n\n      dx -= width / 2;\n      dy -= height / 2;\n\n      // Allow for pixel rounding\n      if (renderer.roundPixels) {\n        renderer.context.setTransform(\n          wt.a,\n          wt.b,\n          wt.c,\n          wt.d,\n          (wt.tx * renderer.resolution) | 0,\n          (wt.ty * renderer.resolution) | 0\n        );\n\n        dx = dx | 0;\n        dy = dy | 0;\n      } else {\n        renderer.context.setTransform(\n          wt.a,\n          wt.b,\n          wt.c,\n          wt.d,\n          wt.tx * renderer.resolution,\n          wt.ty * renderer.resolution\n        );\n      }\n\n      const resolution = texture.baseTexture.resolution;\n\n      this.adaptedNodeCanvas(texture.baseTexture);\n\n      let sx, sy, dw, dh;\n      sx = texture._frame.x;\n      sy = texture._frame.y;\n\n      if (texture.trim) {\n        dw = texture.trim.width;\n        dh = texture.trim.height;\n      } else {\n        dw = width;\n        dh = height;\n      }\n\n      renderer.context.drawImage(\n        texture.baseTexture.source,\n        sx * resolution,\n        sy * resolution,\n        width * resolution,\n        height * resolution,\n        dx * renderer.resolution,\n        dy * renderer.resolution,\n        dw * renderer.resolution,\n        dh * renderer.resolution\n      );\n      // 0 0 100 100 -50 -50 100 100\n    }\n  }\n\n  adaptedNodeCanvas(baseTexture) {\n    if (!baseTexture.source) return;\n    if (baseTexture.source.isPSCanvas) return;\n\n    if (this.isImageData(baseTexture.source)) {\n      const { source, width, height } = baseTexture;\n      baseTexture.source = PsImage.convertToCanvas(source, width, height);\n    }\n  }\n\n  isImageData(data) {\n    if (!data) return false;\n    if (data.width && data.height && data.data && data.data.length) return true;\n    return false;\n  }\n\n  destroy() {\n    this.renderer = null;\n  }\n}\n\nCanvasRenderer.registerPlugin(\"sprite\", CanvasSpriteRenderer);\n"],"file":"CanvasSpriteRenderer.js"}