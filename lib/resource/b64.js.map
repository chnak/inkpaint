{"version":3,"sources":["../../src/resource/b64.js"],"names":["_keyStr","encodeBinary","input","output","inx","length","bytebuffer","encodedCharIndexes","jnx","charCodeAt","paddingBytes","charAt"],"mappings":";;;;;;AAAA,IAAMA,OAAO,GAAG,mEAAhB;;AAEO,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAClC,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,GAAG,GAAG,CAAV;;AAEA,SAAOA,GAAG,GAAGF,KAAK,CAACG,MAAnB,EAA2B;AACzB;AACA,QAAMC,UAAU,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAnB;AACA,QAAMC,kBAAkB,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAA3B;;AAEA,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,UAAU,CAACD,MAAnC,EAA2C,EAAEG,GAA7C,EAAkD;AAChD,UAAIJ,GAAG,GAAGF,KAAK,CAACG,MAAhB,EAAwB;AACtBC,QAAAA,UAAU,CAACE,GAAD,CAAV,GAAkBN,KAAK,CAACO,UAAN,CAAiBL,GAAG,EAApB,IAA0B,IAA5C;AACD,OAFD,MAEO;AACLE,QAAAA,UAAU,CAACE,GAAD,CAAV,GAAkB,CAAlB;AACD;AACF,KAXwB,CAazB;AACA;;;AACAD,IAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwBD,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAzC,CAfyB,CAiBzB;;AACAC,IAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAyB,CAACD,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAjB,KAAyB,CAA1B,GAAgCA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAzE,CAlByB,CAoBzB;;AACAC,IAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAyB,CAACD,UAAU,CAAC,CAAD,CAAV,GAAgB,IAAjB,KAA0B,CAA3B,GAAiCA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAA1E,CArByB,CAuBzB;;AACAC,IAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwBD,UAAU,CAAC,CAAD,CAAV,GAAgB,IAAxC,CAxByB,CA0BzB;;AACA,QAAMI,YAAY,GAAGN,GAAG,IAAIF,KAAK,CAACG,MAAN,GAAe,CAAnB,CAAxB;;AAEA,YAAQK,YAAR;AACE,WAAK,CAAL;AACE;AACAH,QAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,EAAxB;AACAA,QAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,EAAxB;AACA;;AAEF,WAAK,CAAL;AACE;AACAA,QAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,EAAxB;AACA;;AAEF;AACE;AAAO;AAbX,KA7ByB,CA6CzB;AACA;;;AACA,SAAK,IAAIC,IAAG,GAAG,CAAf,EAAkBA,IAAG,GAAGD,kBAAkB,CAACF,MAA3C,EAAmD,EAAEG,IAArD,EAA0D;AACxDL,MAAAA,MAAM,IAAIH,OAAO,CAACW,MAAR,CAAeJ,kBAAkB,CAACC,IAAD,CAAjC,CAAV;AACD;AACF;;AAED,SAAOL,MAAP;AACD","sourcesContent":["const _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nexport function encodeBinary(input) {\n  let output = \"\";\n  let inx = 0;\n\n  while (inx < input.length) {\n    // Fill byte buffer array\n    const bytebuffer = [0, 0, 0];\n    const encodedCharIndexes = [0, 0, 0, 0];\n\n    for (let jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    }\n\n    // Get each encoded character, 6 bits at a time\n    // index 1: first 6 bits\n    encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n    // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n    encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n    // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n    encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n    // index 3: forth 6 bits (6 least significant bits from input byte 3)\n    encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n    // Determine whether padding happened, and adjust accordingly\n    const paddingBytes = inx - (input.length - 1);\n\n    switch (paddingBytes) {\n      case 2:\n        // Set last 2 characters to padding char\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n\n      case 1:\n        // Set last character to padding char\n        encodedCharIndexes[3] = 64;\n        break;\n\n      default:\n        break; // No padding - proceed\n    }\n\n    // Now we will grab each appropriate character out of our keystring\n    // based on our index array and append it to the output string\n    for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[jnx]);\n    }\n  }\n\n  return output;\n}\n"],"file":"b64.js"}