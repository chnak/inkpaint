{"version":3,"sources":["../../src/text/TextMetrics.js"],"names":["TextMetrics","constructor","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","wordWrap","canvas","_canvas","undefined","font","toFontString","measureFont","context","getContext","outputText","split","Array","length","i","lineWidth","letterSpacing","Math","max","strokeThickness","dropShadow","dropShadowDistance","fontSize","leading","line","cache","whiteSpace","collapseSpaces","collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","tokenize","token","isNewline","addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","getFromCache","canBreakWords","breakWords","characters","j","char","k","nextChar","lastChar","canBreakChars","characterWidth","isLastToken","newLine","trimRight","key","spacing","slice","_newlines","indexOf","charCodeAt","_breakingSpaces","push","index","_fonts","properties","_context","metricsString","METRICS_STRING","BASELINE_SYMBOL","ceil","baseline","BASELINE_MULTIPLIER","fillStyle","fillRect","textBaseline","fillText","imagedata","getImageData","data","pixels","idx","stop","ascent","descent","clearMetrics","Doc","createElement"],"mappings":"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","sourcesContent":["import Doc from \"../polyfill/Doc\";\n\nexport default class TextMetrics {\n  constructor(\n    text,\n    style,\n    width,\n    height,\n    lines,\n    lineWidths,\n    lineHeight,\n    maxLineWidth,\n    fontProperties\n  ) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n\n  static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {\n    wordWrap =\n      wordWrap === undefined || wordWrap === null ? style.wordWrap : wordWrap;\n    const font = style.toFontString();\n    const fontProperties = TextMetrics.measureFont(font);\n    const context = canvas.getContext(\"2d\");\n\n    context.font = font;\n\n    const outputText = wordWrap\n      ? TextMetrics.wordWrap(text, style, canvas)\n      : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth =\n        context.measureText(lines[i]).width +\n        (lines[i].length - 1) * style.letterSpacing;\n\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth + style.strokeThickness;\n\n    if (style.dropShadow) {\n      width += style.dropShadowDistance;\n    }\n\n    const lineHeight =\n      style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    let height =\n      Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) +\n      (lines.length - 1) * (lineHeight + style.leading);\n\n    if (style.dropShadow) {\n      height += style.dropShadowDistance;\n    }\n\n    return new TextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n  }\n\n  static wordWrap(text, style, canvas = TextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\");\n\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n\n    const cache = {};\n    const { letterSpacing, whiteSpace } = style;\n\n    // How to handle whitespaces\n    const collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);\n    const collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);\n\n    // whether or not spaces may be added to the beginning of lines\n    let canPrependSpaces = !collapseSpaces;\n\n    // There is letterSpacing after every char except the last one\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n    // so for convenience the above needs to be compared to width + 1 extra letterSpace\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n    // ________________________________________________\n    // And then the final space is simply no appended to each line\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n    // break text into words, spaces and newline chars\n    const tokens = TextMetrics.tokenize(text);\n\n    for (let i = 0; i < tokens.length; i++) {\n      // get the word, space or newlineChar\n      let token = tokens[i];\n\n      // if word is a new line\n      if (TextMetrics.isNewline(token)) {\n        // keep the new line\n        if (!collapseNewlines) {\n          lines += TextMetrics.addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n\n        // if we should collapse new lines\n        // we simply convert it into a space\n        token = \" \";\n      }\n\n      // if we should collapse repeated whitespaces\n      if (collapseSpaces) {\n        // check both this and the last tokens for spaces\n        const currIsBreakingSpace = TextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = TextMetrics.isBreakingSpace(\n          line[line.length - 1]\n        );\n\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n\n      // get word width from cache if possible\n      const tokenWidth = TextMetrics.getFromCache(\n        token,\n        letterSpacing,\n        cache,\n        context\n      );\n\n      // word is longer than desired bounds\n      if (tokenWidth > wordWrapWidth) {\n        // if we are not already at the beginning of a line\n        if (line !== \"\") {\n          // start newlines for overflow words\n          lines += TextMetrics.addLine(line);\n          line = \"\";\n          width = 0;\n        }\n\n        // break large word over multiple lines\n        if (TextMetrics.canBreakWords(token, style.breakWords)) {\n          // break word into characters\n          const characters = token.split(\"\");\n\n          // loop the characters\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n\n            let k = 1;\n            // we are not at the end of the token\n\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              const lastChar = char[char.length - 1];\n\n              // should not split chars\n              if (\n                !TextMetrics.canBreakChars(\n                  lastChar,\n                  nextChar,\n                  token,\n                  j,\n                  style.breakWords\n                )\n              ) {\n                // combine chars & move forward one\n                char += nextChar;\n              } else {\n                break;\n              }\n\n              k++;\n            }\n\n            j += char.length - 1;\n\n            const characterWidth = TextMetrics.getFromCache(\n              char,\n              letterSpacing,\n              cache,\n              context\n            );\n\n            if (characterWidth + width > wordWrapWidth) {\n              lines += TextMetrics.addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n\n            line += char;\n            width += characterWidth;\n          }\n        }\n\n        // run word out of the bounds\n        else {\n          // if there are words in this line already\n          // finish that line and start a new one\n          if (line.length > 0) {\n            lines += TextMetrics.addLine(line);\n            line = \"\";\n            width = 0;\n          }\n\n          const isLastToken = i === tokens.length - 1;\n\n          // give it its own line if it's not the end\n          lines += TextMetrics.addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      }\n\n      // word could fit\n      else {\n        // word won't fit because of existing words\n        // start a new line\n        if (tokenWidth + width > wordWrapWidth) {\n          // if its a space we don't want it\n          canPrependSpaces = false;\n\n          // add a new line\n          lines += TextMetrics.addLine(line);\n\n          // start a new line\n          line = \"\";\n          width = 0;\n        }\n\n        // don't add spaces to the beginning of lines\n        if (\n          line.length > 0 ||\n          !TextMetrics.isBreakingSpace(token) ||\n          canPrependSpaces\n        ) {\n          // add the word to the current line\n          line += token;\n\n          // update width counter\n          width += tokenWidth;\n        }\n      }\n    }\n\n    lines += TextMetrics.addLine(line, false);\n\n    return lines;\n  }\n\n  static addLine(line, newLine = true) {\n    line = TextMetrics.trimRight(line);\n    line = newLine ? `${line}\\n` : line;\n    return line;\n  }\n\n  static getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n\n    if (width === undefined) {\n      const spacing = key.length * letterSpacing;\n\n      width = context.measureText(key).width + spacing;\n      cache[key] = width;\n    }\n\n    return width;\n  }\n\n  static collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n\n  static collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n\n  static trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n\n      if (!TextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n\n      text = text.slice(0, -1);\n    }\n\n    return text;\n  }\n\n  static isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n\n    return TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0;\n  }\n\n  static isBreakingSpace(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n\n    return TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;\n  }\n\n  static tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n\n      if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n\n        tokens.push(char);\n\n        continue;\n      }\n\n      token += char;\n    }\n\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n\n    return tokens;\n  }\n\n  static canBreakWords(token, breakWords) {\n    return breakWords;\n  }\n\n  static canBreakChars(\n    char,\n    nextChar,\n    token,\n    index,\n    breakWords // eslint-disable-line no-unused-vars\n  ) {\n    return true;\n  }\n\n  static measureFont(font) {\n    // as this method is used for preparing assets, don't recalculate things if we don't need to\n    if (TextMetrics._fonts[font]) {\n      return TextMetrics._fonts[font];\n    }\n\n    const properties = {};\n\n    const canvas = TextMetrics._canvas;\n    const context = TextMetrics._context;\n\n    context.font = font;\n\n    const metricsString =\n      TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;\n    const width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(\n      context.measureText(TextMetrics.BASELINE_SYMBOL).width\n    );\n    const height = 2 * baseline;\n\n    baseline = (baseline * TextMetrics.BASELINE_MULTIPLIER) | 0;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    context.fillStyle = \"#f00\";\n    context.fillRect(0, 0, width, height);\n    context.font = font;\n    context.textBaseline = \"alphabetic\";\n    context.fillStyle = \"#000\";\n    context.fillText(metricsString, 0, baseline);\n\n    const imagedata = context.getImageData(0, 0, width, height).data;\n    const pixels = imagedata.length;\n    const line = width * 4;\n\n    let i = 0;\n    let idx = 0;\n    let stop = false;\n\n    // ascent. scan from top to bottom until we find a non red pixel\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n\n    properties.ascent = baseline - i;\n\n    idx = pixels - line;\n    stop = false;\n\n    // descent. scan from bottom to top until we find a non red pixel\n    for (i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n\n    properties.descent = i - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n\n    TextMetrics._fonts[font] = properties;\n\n    return properties;\n  }\n\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete TextMetrics._fonts[font];\n    } else {\n      TextMetrics._fonts = {};\n    }\n  }\n}\n\nconst canvas = Doc.createElement(\"canvas\");\ncanvas.width = canvas.height = 10;\nTextMetrics._canvas = canvas;\nTextMetrics._context = canvas.getContext(\"2d\");\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|Éq\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics._newlines = [\n  0x000a, // line feed\n  0x000d // carriage return\n];\nTextMetrics._breakingSpaces = [\n  0x0009, // character tabulation\n  0x0020, // space\n  0x2000, // en quad\n  0x2001, // em quad\n  0x2002, // en space\n  0x2003, // em space\n  0x2004, // three-per-em space\n  0x2005, // four-per-em space\n  0x2006, // six-per-em space\n  0x2008, // punctuation space\n  0x2009, // thin space\n  0x200a, // hair space\n  0x205f, // medium mathematical space\n  0x3000 // ideographic space\n];\n"],"file":"TextMetrics.js"}